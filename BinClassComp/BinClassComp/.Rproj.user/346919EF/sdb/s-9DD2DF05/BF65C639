{
    "collab_server" : "",
    "contents" : "options(digits=10)\noptions(scipen=10)\nlibrary(RODBC)\nlibrary(corrplot)\nlibrary(ggplot2)\nlibrary(factoextra)\nlibrary(FactoMineR)\nlibrary(gridExtra)\nlibrary(LICORS)\nlibrary( BBmisc )\nlibrary(Rtsne)\nlibrary(umap)\nlibrary( cluster )\nlibrary(rgl)\nlibrary(mclust)\n\n#' Get data for clustering\n#'\n#' Get data of Sql Server\n#' @param name_object is name of oject\n#' @param query is query text\n#' @param connectionStringDataMine is a connection string\n#' @return list of data and y_name\n#' @export\nget_data_clust<-function(name_object=nULL,query,connection_string=nULL)\n{\n\tdbhandle <- odbcDriverConnect(connection_string)\n\tdata<-sqlQuery(dbhandle,query)\n\ton.exit(odbcClose(dbhandle))\n\treturn(list(name_object=name_object,data=data))\n}\n\n#' Prepare evidences before clustering\n#'\n#' #' Prepare evidences before clustering\n#' @param data data for clustering\n#' @param name_object is name of oject\n#' @return plot\n#' @export\nprepare_evidences<-function(data,name_object)\n{\n\tx_index<-which(!names(data) %in% name_object)\n\tfor (i in x_index)\n\t{\n\t\tif(is.factor(data[,i])==FALSE)\n\t\t{\n\t\t\tx_i<-log(data[,i]+abs(min(data[,i]))+1)\n\t\t\tprint(names(data)[i])\n\n\n\t\t\tw<-2*IQR(x_i)*length(x_i)^(-1/3)\n\t\t\tif(w!=0)\n\t\t\t{\n\t\t\t\tz2<-cut(x_i, breaks=pretty(x_i,n=(ceiling(max(x_i)/w))), include.lowest=TRUE,labels=F,right = F)\n\t\t\t\tdata[,i]<-z2\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tz3<-cut(x_i,breaks=1+log2(length(x_i)), labels = FALSE,right=TRUE,include.lowest=TRUE)\n\t\t\t\tdata[,i]<-z3\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprint(past(\"Warning: evidences type is factor:\",names(x)[i]))\n\t\t}\n\t\tdata[,x_index]<-data.frame(scale(data[,x_index]))\n\t}\n\treturn(data=data)\n}\n\n\n#' Get wss\n#'\n#' #' Get wss for clustering\n#' @param x data for clustering\n#' @param cluster is clustering result\n#' @param center is center for cluster\n#' @return value\n#' @export\nget_wss<-function(x, cluster, center)\n{\n\tx<-data.frame(cluster=cluster,x=x)\n\tz<-merge(x,center,by=\"cluster\",all.x = TRUE)\n\tdist<-(z[,seq(2,(ncol(x)))]-z[,seq((ncol(x)+1),ncol(z))])^2\n\tsum_dist<-data.frame(cluster=z$cluster,dist=(apply(dist,1,sum)))\n\twss<-sum(sum_dist$dist)\n\treturn(wss)\n}\n\n#' Get bss\n#'\n#' #' Get bss for clustering\n#' @param x data for clustering\n#' @param cluster is clustering result\n#' @param center is center for cluster\n#' @return value\n#' @export\nget_bss<-function(x,cluster,center)\n{\n\tcenter_all<-t(data.frame(apply(x,2,mean)))\n\tcenter_all<-center_all[rep(1,nrow(center)),]\n\tsum_dist<-data.frame(cluster=center$cluster,dist=apply((center[,-1]-center_all)^2,1,sum))\n\tcount_object<-aggregate(data.frame(n_c=cluster), list(cluster=cluster), length)\n\tsum_dist<-merge(sum_dist,count_object,by=\"cluster\",all.x = TRUE)\n\tbss<-sum(sum_dist$dist*sum_dist$n_c)\n\treturn(bss)\n}\n\n#' Get plot\n#'\n#' Plot clustering result\n#' @param data data for clustering\n#' @param name_object is name of oject\n#' @param cluster is vector of cluster\n#' @param nameTest is name of plot\n#' @param nameTest is metod for plot for count evidences > 3\n#' @return plot\n#' @export\nget_plot<-function(data,name_object,cluster,nameTest=\"test\",metod=\"umap\")\n{\n\tx_index<-which(!names(data) %in% name_object)\n\tx<-data[,x_index]\n\tif(ncol(x)==2)\n\t{\n\t\tp<-ggplot(data.frame('cluster'=as.factor(cluster),x), aes_string(x=x[,1], y=x[,2], color='cluster')) +\n\t\t\tgeom_point(size=1) +\n\t\t\tguides(colour=guide_legend(override.aes=list(size=6))) +\n\t\t\txlab(\"\") + ylab(\"\") +\n\t\t\tggtitle(nameTest) +\n\t\t\ttheme_light(base_size=20) +\n\t\t\ttheme(axis.text.x=element_blank(),\n\t\t\t\t\t\taxis.text.y=element_blank(),\n\t\t\t\t\t\tlegend.direction = \"horizontal\",\n\t\t\t\t\t\tlegend.position = \"bottom\",\n\t\t\t\t\t\tlegend.box = \"horizontal\")\n\t\tgrid.arrange(p,ncol=1, nrow=1)\n\t}\n\tif(ncol(x)==3)\n\t{\n\t\tplot3d(x[,1], x[,2], x[,3], xlab=names(x)[1], ylab=names(x)[2], zlab=names(x)[3],\n\t\t\t\t\t type=\"p\", size=5, lit=F, main = nameTest, col = cluster)\n\t\tlegend3d(\"topright\",pch = 16, legend =unique(cluster) , col =unique(cluster), cex=2, inset=c(0.06))\n\t}\n\tif(ncol(x)>3)\n\t{\n\t\tif(metod==\"tsne\")\n\t\t{\n\t\t\txy<- as.data.frame(Rtsne(as.matrix(x), check_duplicates=FALSE, pca=TRUE, perplexity=30, theta=0.5, dims=2)$Y)\n\t\t}\n\t\tif(metod==\"umap\")\n\t\t{\n\t\t\txy<-umap(x[,-1])$layout\n\t\t}\n\n\t\tp<-ggplot(data.frame('cluster'=as.factor(cluster),xy), aes_string(x=xy[,1], y=xy[,2], color='cluster')) +\n\t\t\tgeom_point(size=1) +\n\t\t\tguides(colour=guide_legend(override.aes=list(size=6))) +\n\t\t\txlab(\"\") + ylab(\"\") +\n\t\t\tggtitle(nameTest) +\n\t\t\ttheme_light(base_size=20) +\n\t\t\ttheme(axis.text.x=element_blank(),\n\t\t\t\t\t\taxis.text.y=element_blank(),\n\t\t\t\t\t\tlegend.direction = \"horizontal\",\n\t\t\t\t\t\tlegend.position = \"bottom\",\n\t\t\t\t\t\tlegend.box = \"horizontal\")\n\t\tgrid.arrange(p,ncol=1, nrow=1)\n\t}\n}\n\n#' Get cluster info\n#'\n#' Get cluster info\n#' @param data data for clustering\n#' @param name_object is name of oject\n#' @param cluster is vector of cluster\n#' @return data frame\n#' @export\nget_cluster_info<-function(data,name_object,cluster)\n{\n\tx_index<-which(!names(data) %in% name_object)\n\tx<-data[,x_index]\n\tr<-data.frame(\"cluster\"=cluster,x)\n\tg<-NULL\n\tg_i<-data.frame()\n\tfor( i in 1:length(unique(r$cluster)))\n\t{\n\t\tg<-rbind(g,apply((r[which(r$cluster==i),-1]),2,median))\n\t\tg<-rbind(g,apply((r[which(r$cluster==i),-1]),2,mean))\n\t\tg<-rbind(g,apply((r[which(r$cluster==i),-1]),2,max))\n\t\tg<-rbind(g,apply((r[which(r$cluster==i),-1]),2,min))\n\t\tg_i<-rbind(g_i,data.frame(\"agr\"=c(\"median\",\"mean\",\"max\",\"min\"), \"cluster\"=i,\"count_object\"=nrow(r[which(r$cluster==i),-1])))\n\t}\n\treturn(cbind(g_i,g))\n}\n\n#' Plot box plot\n#'\n#' plot box plot clustering result\n#' @param data data for clustering\n#' @param name_object is name of oject\n#' @param cluster is vector of cluster\n#' @return box plot\n#' @export\nget_box_plot<-function(data,name_object,cluster)\n{\n\tx_index<-which(!names(data) %in% name_object)\n\tx<-data[,x_index]\n\tr<-data.frame(\"cluster\"=cluster,x)\n\tpar(mfrow=c(3,1))\n\tfor(i in 2:ncol(r))\n\t{\n\t\ty<-log(r[,i]+abs(min(r[,i]))+1)\n\t\tboxplot(y ~ r$cluster,\n\t\t\t\t\t\txlab = 'cluster',\n\t\t\t\t\t\tylab = names(r)[i],\n\t\t\t\t\t\tmain = 'BoxPot',\n\t\t\t\t\t\tcol = \"coral\", data = r)\n\t}\n}\n\n#' Get box plot\n#' @param data data for clustering\n#' @param name_object is name of oject\n#' @param cluster is vector of clusters\n#' @param center is center for clusters\n#' @param k is count of clusters\n#' @return list\n#' @export\nget_quality<-function(data,name_object,cluster,center,k)\n{\n\tx_index<-which(!names(data) %in% name_object)\n\tx<-data[,x_index]\n\tN<-length(cluster)\n\tK<-k\n\tD<-ncol(x)\n\tWSS<-get_wss(x, cluster, center)\n\tBSS<-get_bss(x, cluster,center)\n\tBH<-WSS/K\n\tXu<-D*log(sqrt(WSS/(D*N^2)))+log(K)\n\tH<-log(WSS/BSS)\n\tWB <-(K*WSS)/BSS\n\tCH <-(WSS/(N-K))/(BSS/(K-1))\n\tBIC<-WSS+log(N)*D*K\n\treturn(data.frame(WSS,BH,Xu,H,WB,BIC))\n}\n\n#' Get clusters\n#'\n#' Get clusters\n#' @param data data for clustering\n#' @param name_object is name of oject\n#' @param model is model for clustering\n#' @param k is count of clusters\n#' @return data frame\n#' @export\nget_cluster<-function(data, name_object, model='kmeans', k=5)\n{\n\tprint(model)\n\tx_index<-which(!names(data) %in% name_object)\n\tx<-data[,x_index]\n\tsilhouetteAvg<-NA\n\tif(model=='kmeans')\n\t{\n\t\tfit<-kmeans(x,k,iter.max = 3000, nstart = 3,algorithm=\"Forgy\")\n\t\tcluster<- fit$cluster\n\t\tcenter<-data.frame(cluster=as.numeric(row.names(fit$center)),fit$center)\n\t}\n\tif(model=='kmeanspp')\n\t{\n\t\tfit<-kmeanspp(x,k)\n\t\tcluster<- fit$cluster\n\t\tcenter<-data.frame(cluster=as.numeric(row.names(fit$center)),fit$center)\n\t}\n\tif(model=='clara')\n\t{\n\t\tfit<- clara(x,k=k, metric = \"euclidean\", samples=500,sampsize =500)\n\t\tcluster <-fit$clustering\n\t\tcenter<-data.frame(cluster=unique(fit$clustering),fit$medoids)\n\t}\n\tif(model=='diana')\n\t{\n\t\tfit<- diana(x, metric = \"euclidean\")\n\t\tcluster <- cutree(fit, k=k)\n\t\tcenter<-data.frame(cluster=unique(cluster),apply(x,2,function(y){tapply(y,list(cluster),mean)}))\n\t}\n\tif(model=='agnes')\n\t{\n\t\tfit<- agnes(dist(x), metric = \"manhattan\")\n\t\tcluster <- cutree(fit, k=k)\n\t\tcenter<-data.frame(cluster=unique(cluster),apply(x,2,function(y){tapply(y,list(cluster),mean)}))\n\t}\n\tif(model==\"Mclust\")\n\t{\n\t\tfit <- Mclust(x,G=k)\n\t\tcluster <-fit$classification\n\t\tcenter<-data.frame(cluster=unique(cluster),apply(x,2,function(y){tapply(y,list(cluster),mean)}))\n\t}\n\treturn(list(cluster=cluster,\n\t\t\t\t\t\t\tcenter=center,\n\t\t\t\t\t\t\tmodel_info= list(model=model,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t k=k)))\n}\n\n#' Get clusters\n#'\n#' Start clustering\n#' @param data data for clustering\n#' @param name_object is name of oject\n#' @param model is model for clustering\n#' @param k is count of clusters\n#' @param prepare is logical value for prepare evidences before clustering\n#' @param plot_cluster is logical value for plot cluster\n#' @param cluster_info is logical value for get cluster information\n#' @param box_plot is logical value for box plot cluster\n#' @return list\n#' @export\nclustering_go<-function(data,name_object,model='Mclust',k=3,prepare=FALSE,\n\t\t\t\t\t\t\t\t\t\t\t\tplot_cluster=TRUE,cluster_info=TRUE,box_plot=FALSE)\n{\n\tdata_start<-data\n\tif(prepare)\n\t{\n\t\tdata<-prepare_evidences(data,name_object)\n\t}\n\tcluster<-get_cluster(data, name_object, model, k)\n\tquality<-get_quality(data,name_object,cluster$cluster,cluster$center,k)\n\tif(plot_cluster)\n\t{\n\t\tget_plot(data,name_object,cluster$cluster,nameTest=\"test\",metod=\"umap\")\n\t}\n\tif(cluster_info)\n\t{\n\t\tcluster_info<-get_cluster_info(data_start,name_object,cluster$cluster)\n\t}\n\tif(box_plot)\n\t{\n\t\tget_box_plot(data_start,name_object,cluster$cluster)\n\t}\n\tresult<-data.frame(cluster=cluster$cluster,data_start)\n\treturn(list(result=result,\n\t\t\t\t\t\t\tquality=quality,\n\t\t\t\t\t\t\tcluster_info=cluster_info))\n}\n\n#' find k\n#'\n#' Get informationt about index for finding count clusters\n#' @param data data for clustering\n#' @param name_object is name of oject\n#' @param model is model for clustering\n#' @param range_k is vector of counts of clusters\n#' @param prepare is logical value for prepare evidences before clustering\n#' @return list\n#' @export\nfind_k<-function(data,name_object,model='kmeans',range_k=2:30,prepare=TRUE)\n{\n\tif(range_k %in% 1)\n\t{\n\t\trange_k<-range_k[-which(range_k %in% 1)]\n\t}\n\tif(prepare)\n\t{\n\t\tdata<-prepare_evidences(data,name_object)\n\t}\n\telse\n\t{\n\t\tdata[,which(!names(data) %in% name_object)]<-scale(data[,which(!names(data) %in% name_object)])\n\t}\n\t#get measure by k\n\tquality<-data.frame()\n\tfor(k in range_k)\n\t{\n\t\tcluster<-get_cluster(data, name_object, model, k=k)\n\t\tquality<-rbind(quality,data.frame(k=k,get_quality(data,name_object,cluster$cluster,cluster$center,k=k)))\n\t}\n\tpar(mfrow=c(2,2))\n\t#get diff_WSS\n\tcluster<-get_cluster(data, name_object, model, k=(range_k[1]-1))\n\tdop_wss<-get_quality(data,name_object,cluster$cluster,cluster$center,k=(range_k[1]-1))$WSS\n\tquality$diff_WSS<--diff(c(dop_wss,quality$WSS))/quality$WSS[1]\n\t#find k by min\n\tbest_k<-apply(quality[,-1],2,function(y){quality$k[which.min(y)]})\n\t#find k by cumsum+plot\n\tbreaks<-t(as.data.frame(combn(range_k[-c(1,length(range_k))], 2)))\n\tbest_break_min<-c()\n\tbest_break_max<-c()\n\ta<-range_k[1]\n\tb<-range_k[length(range_k)]\n\tfor(i in 2:ncol(quality))\n\t{\n\t\tplot(range_k,quality[,i],type = \"l\",main = names(quality)[i],xlab='k',ylab='value')\n\t\tpoints(best_k[i-1],quality[which(quality$k==best_k[i-1]),i],col=\"red\")\n\t\t#cumsum<-max(quality[,i])-quality[,i]\n\t\tcumsum<-cumsum(quality[,i]+max(abs(quality[,i]))+1)\n\t\tcumsum<-cumsum/max(cumsum)\n\t\tfa<-cumsum[1]\n\t\tfb<-cumsum[length(range_k)]\n\t\tsquare<-apply(breaks,1,function(x)\n\t\t{\n\t\t\ts<-(fa+cumsum[which(range_k==x[1])])*(x[1]-a)/2+\n\t\t\t\t(fb+cumsum[which(range_k==x[2])])*(b-x[2])/2+\n\t\t\t\t(cumsum[which(range_k==x[1])]+cumsum[which(range_k==x[2])])*(x[2]-x[1])/2\n\t\t\treturn(s)\n\t\t})\n\t\tbest_break<-breaks[which.max(square),]\n\t\tbest_break_min<-c(best_break_min,best_break[1])\n\t\tbest_break_max<-c(best_break_max,best_break[2])\n\t\tplot(range_k,cumsum,type = \"l\",main = names(quality)[i],xlab='k',ylab='cumulative value')\n\t\tlines(c(a,best_break,b),c(fa,cumsum[which(range_k %in% best_break)],fb),col=\"blue\",lty=3)\n\t\tpoints(best_break,cumsum[which(range_k %in% best_break)],col=\"red\")\n\t}\n\tbest_k<-rbind(best_k,best_break_min)\n\tbest_k<-rbind(best_k,best_break_max)\n\treturn(list(best_k=best_k,quality=quality))\n}\n",
    "created" : 1561381659910.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "40|1|69|0|\n81|1|88|0|\n99|1|107|0|\n120|1|168|0|\n179|1|194|0|\n205|1|219|0|\n230|1|245|0|\n257|1|302|0|\n319|1|343|0|\n356|1|415|0|\n",
    "hash" : "3930517181",
    "id" : "BF65C639",
    "lastKnownWriteTime" : 1561386945,
    "last_content_update" : 1561386945457,
    "path" : "D:/R/BinClassComp/BinClassComp/R/clustering.R",
    "project_path" : "R/clustering.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}